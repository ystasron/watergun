"use strict";

var utils = require("../utils");

var scheduledMessages = new Map();
var messageIdCounter = 0;

module.exports = function(defaultFuncs, api, ctx) {
  return {
    schedule: function(message, threadID, delay, callback) {
      var resolveFunc = function() {};
      var rejectFunc = function() {};
      var returnPromise = new Promise(function(resolve, reject) {
        resolveFunc = resolve;
        rejectFunc = reject;
      });

      if (typeof callback !== "function") {
        callback = function(err, data) {
          if (err) return rejectFunc(err);
          resolveFunc(data);
        };
      }

      if (!threadID) {
        return callback({ error: "threadID is required" });
      }

      if (!message) {
        return callback({ error: "message is required" });
      }

      var delayMs = utils.parseTimeString(delay);
      if (delayMs <= 0) {
        return callback({ error: "Invalid delay. Use format like '5m', '1h', '30s' or milliseconds" });
      }

      var scheduleId = "sched_" + (++messageIdCounter) + "_" + Date.now();
      var sendTime = Date.now() + delayMs;

      var timeoutId = setTimeout(function() {
        var msgBody = typeof message === "string" ? { body: message } : message;
        
        api.sendMessage(msgBody, threadID, function(err, info) {
          scheduledMessages.delete(scheduleId);
          
          if (err) {
            console.error("[ AMINUL-FCA ]", "Scheduled message failed:", err);
          } else {
            console.log("[ AMINUL-FCA ]", "Scheduled message sent:", scheduleId);
          }
        });
      }, delayMs);

      scheduledMessages.set(scheduleId, {
        id: scheduleId,
        threadID: threadID,
        message: message,
        scheduledFor: sendTime,
        createdAt: Date.now(),
        timeoutId: timeoutId
      });

      callback(null, {
        scheduleId: scheduleId,
        threadID: threadID,
        scheduledFor: new Date(sendTime).toISOString(),
        delayMs: delayMs
      });

      return returnPromise;
    },

    cancel: function(scheduleId, callback) {
      var resolveFunc = function() {};
      var rejectFunc = function() {};
      var returnPromise = new Promise(function(resolve, reject) {
        resolveFunc = resolve;
        rejectFunc = reject;
      });

      if (typeof callback !== "function") {
        callback = function(err, data) {
          if (err) return rejectFunc(err);
          resolveFunc(data);
        };
      }

      var scheduled = scheduledMessages.get(scheduleId);
      if (!scheduled) {
        return callback({ error: "Scheduled message not found" });
      }

      clearTimeout(scheduled.timeoutId);
      scheduledMessages.delete(scheduleId);

      callback(null, {
        scheduleId: scheduleId,
        cancelled: true
      });

      return returnPromise;
    },

    list: function(callback) {
      var resolveFunc = function() {};
      var rejectFunc = function() {};
      var returnPromise = new Promise(function(resolve, reject) {
        resolveFunc = resolve;
        rejectFunc = reject;
      });

      if (typeof callback !== "function") {
        callback = function(err, data) {
          if (err) return rejectFunc(err);
          resolveFunc(data);
        };
      }

      var list = [];
      scheduledMessages.forEach(function(value, key) {
        list.push({
          scheduleId: key,
          threadID: value.threadID,
          scheduledFor: new Date(value.scheduledFor).toISOString(),
          createdAt: new Date(value.createdAt).toISOString(),
          timeRemaining: Math.max(0, value.scheduledFor - Date.now())
        });
      });

      callback(null, {
        count: list.length,
        scheduled: list
      });

      return returnPromise;
    },

    cancelAll: function(callback) {
      var resolveFunc = function() {};
      var rejectFunc = function() {};
      var returnPromise = new Promise(function(resolve, reject) {
        resolveFunc = resolve;
        rejectFunc = reject;
      });

      if (typeof callback !== "function") {
        callback = function(err, data) {
          if (err) return rejectFunc(err);
          resolveFunc(data);
        };
      }

      var count = scheduledMessages.size;
      
      scheduledMessages.forEach(function(value) {
        clearTimeout(value.timeoutId);
      });
      
      scheduledMessages.clear();

      callback(null, {
        cancelledCount: count
      });

      return returnPromise;
    }
  };
};
