"use strict";

var utils = require("../utils");

module.exports = function(defaultFuncs, api, ctx) {
  return async function sendBatchMessages(messages, options = {}) {
    var resolveFunc = function() {};
    var rejectFunc = function() {};
    var returnPromise = new Promise(function(resolve, reject) {
      resolveFunc = resolve;
      rejectFunc = reject;
    });

    if (!Array.isArray(messages) || messages.length === 0) {
      rejectFunc({ error: "messages must be a non-empty array" });
      return returnPromise;
    }

    var delay = options.delay || 1000;
    var continueOnError = options.continueOnError !== false;
    var results = [];

    for (var i = 0; i < messages.length; i++) {
      var msg = messages[i];
      
      if (!msg.threadID || !msg.body) {
        results.push({
          index: i,
          success: false,
          error: "Missing threadID or body"
        });
        continue;
      }

      try {
        var messageInfo = await new Promise(function(resolve, reject) {
          api.sendMessage(
            { body: msg.body, attachment: msg.attachment, mentions: msg.mentions },
            msg.threadID,
            function(err, info) {
              if (err) reject(err);
              else resolve(info);
            }
          );
        });

        results.push({
          index: i,
          success: true,
          threadID: msg.threadID,
          messageID: messageInfo.messageID,
          timestamp: messageInfo.timestamp
        });
      } catch (err) {
        results.push({
          index: i,
          success: false,
          threadID: msg.threadID,
          error: err.error || err.message || "Unknown error"
        });

        if (!continueOnError) {
          rejectFunc({ 
            error: "Batch send failed", 
            failedAt: i, 
            results: results 
          });
          return returnPromise;
        }
      }

      if (i < messages.length - 1 && delay > 0) {
        await utils.sleep(delay);
      }
    }

    resolveFunc({
      total: messages.length,
      successful: results.filter(r => r.success).length,
      failed: results.filter(r => !r.success).length,
      results: results
    });

    return returnPromise;
  };
};
